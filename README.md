# Задача №3044 Сортировка подсчётом(2)
## Решение (сортировка подсчётом)
```python
def counting_sort(arr):
    n = len(arr)
    count = [0] * 20001

    for num in arr:
        count[num + 10000] += 1

    sorted_arr = []
    for i in range(len(count)):
        sorted_arr.extend([i - 10000] * count[i])

    return sorted_arr

n = int(input())
elements = list(map(int, input().split()))
sorted_elements = counting_sort(elements)
print(*sorted_elements)
```
## Объяснение алгоритма
- Создаем массив `count` с нулевыми значениями. Размер массива выбирается таким образом, чтобы можно было учесть все возможные значения элементов входного массива `arr`, сдвинутых на **10000**, чтобы обработать отрицательные числа.
- Проходим по всем элементам входного массива `arr` и увеличиваем на единицу значение в массиве `count` по **индексу**, соответствующему значению элемента с учетом сдвига. Это позволяет нам получить количество вхождений каждого значения в исходном массиве.
- Создаем пустой массив ``sorted_arr``. Затем проходим по массиву `count`, и для каждого индекса, где количество (значение в `count`) больше нуля, добавляем в `sorted_arr` значение этого индекса (с учетом обратного сдвига на **10000**), повторенное столько раз, сколько указано в `count`.

# Задача №1429. Носки
## Решение (сортировка подсчетом)
```python
def calculate_socks_coverage(L, socks, queries):
    coverage = [0] * (L + 1)

    for l, r in socks:
        coverage[l] += 1
        if r + 1 <= L:
            coverage[r + 1] -= 1

    for i in range(1, L + 1):
        coverage[i] += coverage[i - 1]

    return [coverage[q] for q in queries]

L, N, M = map(int, input().split())
socks = [tuple(map(int, input().split())) for _ in range(N)]
queries = [int(input()) for _ in range(M)]
coverages = calculate_socks_coverage(L, socks, queries)

for coverage in coverages:
        print(coverage)
```
## Объяснение алгоритма
- Создается массив coverage, индексируемый от `0` до `L`, где `L` — длина стола. Этот массив будет использоваться для подсчета изменений в толщине слоя носков в каждой точке стола. Изначально все его элементы равны **0**, так как предполагается, что стол не покрыт носками.
- Для каждого носка, заданного парой чисел `(l, r)`, где `l` — левый конец носка, а r — правый конец, алгоритм увеличивает значение в `coverage[l]` на 1 и уменьшает значение в `coverage[r + 1]` на `1`. Это делается для того, чтобы отметить, что начиная с позиции `l` и до позиции `r` включительно, толщина слоя носков увеличивается на `1`. Уменьшение на `1` в позиции `r + 1` нужно для того, чтобы **"отменить"** этот прирост за пределами носка.
- Затем алгоритм проходит по массиву coverage, начиная с первой позиции и до конца, суммируя значения. Таким образом, значение в каждой позиции массива после этого шага показывает, сколько слоев носков покрывает соответствующую точку стола. Это возможно, потому что приросты и уменьшения, записанные на предыдущем шаге, при суммировании дают аккумулированную толщину покрытия в каждой точке.
- Наконец, для каждого запроса, представляющего собой точку на столе, алгоритм выводит значение из массива coverage, соответствующее этой точке. Это значение является искомой толщиной слоя носков в этой точке.

# Задача №230. Сортировка выбором максимума
## Решение (сортировка выбором)
```python
def counting_cover_thickness(L, N, M, sock_pairs, measurement_points):
    count = [0] * (L + 1)
   
    for l, r in sock_pairs:
        count[l] += 1
        count[r] -= 1
    
    for i in range(1, L + 1):
        count[i] += count[i - 1]
    
    cover_thickness = []
    for point in measurement_points:
        cover_thickness.append(count[point])

    return cover_thickness

L, N, M = map(int, input().split())
sock_pairs = []
for _ in range(N):
    l, r = map(int, input().split())
    sock_pairs.append((l, r))
measurement_points = list(map(int, input().split()))
results = counting_cover_thickness(L, N, M, sock_pairs, measurement_points)
print(*results)
```
## Объяснение алгоритма
- Создается массив `count` размером `L + 1`, где `L` — длина пола. Этот массив будет использоваться для подсчета "накопленной толщины" носков на каждом отрезке пола. Изначально все элементы массива установлены в 0.
- Для каждой пары `(l, r)` увеличиваем значение в `count[l]` на 1 и уменьшаем значение в `count[r]` на 1. Это делается для реализации техники **"разностей"** или **"prefix sum"** (префиксных сумм), где `l` — начало участка с носками, а `r` — конец. Увеличение на 1 на начале диапазона и уменьшение на 1 после окончания диапазона позволяет нам в дальнейшем быстро рассчитать **"текущую толщину"** слоя носков в любой точке.
- Проходим по массиву count, начиная с первого элемента, и прибавляем к текущему элементу значение предыдущего. Таким образом, каждый элемент `count[i]` будет содержать сумму всех предыдущих изменений, что фактически дает нам толщину слоя носков на полу до точки i включительно.
- Для каждой точки измерения из `measurement_points` определяем толщину слоя носков, обращаясь к соответствующему элементу массива count и добавляем эту толщину в список `cover_thickness`.

# Задача №232. Сортировка вставками
## Решение (сортировка вставками)
```python
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2
  
    if l < n and arr[i] < arr[l]:
        largest = l
  
    if r < n and arr[largest] < arr[r]:
        largest = r
  
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
  
def heap_sort(arr):
    n = len(arr)
  
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
  
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
  

size = int(input())
nums = list(map(int, input().split()))

heap_sort(nums)
print(*nums)
```
## Объяснение алгоритма
Функция `heapify` принимает массив arr, его размер n и индекс i элемента, для которого нужно восстановить свойство кучи. В двоичной куче для каждого узла i его дети могут быть найдены на позициях `2*i + 1` (левый ребенок) и `2*i + 2` (правый ребенок).
- Сначала устанавливается, что текущий элемент (с индексом `i`) является наибольшим.
- Затем проверяется, не выходит ли левый дочерний элемент за пределы массива (то есть он существует) и больше ли он текущего **"наибольшего"** элемента. Если да, то **"наибольший"** индекс обновляется на индекс левого ребенка.
- Аналогично проверяется правый ребенок.
- Если после этих проверок индекс **"наибольшего"** элемента изменился, текущий элемент и элемент, найденный как **"наибольший"**, меняются местами.
- Если была произведена замена, функция рекурсивно вызывается для поддерева с корнем в только что перемещенном элементе, чтобы восстановить свойство кучи.
Функция `heap_sort` принимает массив arr для сортировки.
- Сначала массив преобразуется в максимальную кучу. Для этого `heapify` вызывается для всех нелистовых узлов (начиная с последнего нелистового узла до корня). Это строит максимальную кучу, где самый большой элемент находится в корне кучи.
- Затем элементы массива сортируются путем повторного удаления элемента из корня кучи (который является максимальным) и помещения его в конец массива, с последующим восстановлением свойства максимальной кучи для оставшейся части массива.

# Задача №754. Пирамидальная сортировка
## Решение (Пирамидальная сортировка)
```python
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2
  
    if l < n and arr[i] < arr[l]:
        largest = l
  
    if r < n and arr[largest] < arr[r]:
        largest = r
  
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
  
def heap_sort(arr):
    n = len(arr)
  
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
  
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
  

size = int(input())
nums = list(map(int, input().split()))

heap_sort(nums)
print(*nums)
```
## Объяснение алгоритма
- Функция heapify принимает три аргумента: массив arr, размер кучи n и индекс i родительского узла. Цель этой функции — убедиться, что поддерево с корнем в узле i удовлетворяет свойству кучи, т.е. значение в родительском узле должно быть больше, чем значения в его дочерних узлах (для максимальной кучи).
- Определяются индексы левого (l = 2 * i + 1) и правого (r = 2 * i + 2) дочерних элементов.
Проверяется, превосходит ли левый дочерний элемент родительский, и если да, то индекс largest обновляется на индекс левого дочернего элемента.
Аналогично проверяется для правого дочернего элемента, и если он больше, чем элемент, указанный в largest, то largest обновляется на индекс правого дочернего элемента.
Если largest не равен текущему родительскому индексу i, происходит обмен элементов, и рекурсивно вызывается heapify для поддерева с корнем в largest для восстановления свойства кучи.
- Создание максимальной кучи (max-heap): Исходный массив преобразуется в максимальную кучу с помощью последовательного вызова heapify начиная с последнего родительского узла до корня кучи. Это гарантирует, что самый большой элемент находится в корне кучи.
- После создания максимальной кучи самый большой элемент (находящийся в корне) меняется местами с последним элементом массива. Размер кучи уменьшается на один (так как последний элемент теперь находится на правильном месте и исключается из дальнейшего рассмотрения). Затем вызывается heapify для корня кучи, чтобы восстановить свойства максимальной кучи. Этот процесс повторяется, пока не будут упорядочены все элементы массива.

# Задача №766. Сортировка слиянием
## Решение (Сортировка слиянием)
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    
    left = merge_sort(left)
    right = merge_sort(right)
    
    return merge(left, right)


def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    while i < len(left):
        result.append(left[i])
        i += 1
    
    while j < len(right):
        result.append(right[j])
        j += 1
    
    return result


n = int(input())
nums = list(map(int, input().split()))


sorted_nums = merge_sort(nums)
print(*sorted_nums)
```
## Объяснение алгоритма
- Разделяй и властвуй: Принцип работы алгоритма основан на стратегии "разделяй и властвуй". Это значит, что мы разделяем наш список элементов на более мелкие части, пока не дойдем до отдельных элементов, которые по определению уже "отсортированы" (потому что каждый список из одного элемента не может быть неупорядоченным).
- Разделение на половины: Представь, что у тебя есть стопка бумаг, которые нужно упорядочить. Ты разделяешь стопку пополам, затем каждую из этих стопок снова пополам и так далее, пока не получишь стопки, в которых будет по одному листу.
- Слияние: Как только ты достигнешь этого момента, начинается процесс слияния. Ты берешь две стопки из одного листа и сравниваешь их. Меньший лист идет первым, за ним следует больший. Это простой процесс, потому что каждая стопка уже "отсортирована".
- Слияние в большие группы: Теперь, когда у тебя есть отсортированные пары, ты начинаешь сливать их вместе, сохраняя порядок. Это похоже на слияние двух отсортированных стопок карточек, где ты берешь верхнюю карточку из каждой стопки, сравниваешь их и кладешь наименьшую карточку в новую стопку, которую собираешь. Продолжаешь делать это, пока все карточки не окажутся в одной отсортированной стопке.
